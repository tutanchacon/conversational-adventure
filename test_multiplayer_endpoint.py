#!/usr/bin/env python3
# üéÆ TEST ESPEC√çFICO PARA ENDPOINT MULTIPLAYER

"""
Test completo del endpoint /ws/multiplayer con todas las funcionalidades
"""

import asyncio
import websockets
import json
import logging
import time
from datetime import datetime

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class MultiPlayerWebSocketTester:
    """Tester completo para WebSocket multi-jugador"""
    
    def __init__(self, base_url="ws://localhost:8000"):
        self.base_url = base_url
        self.connections = {}
        self.test_results = []
    
    async def test_basic_connection(self):
        """Test 1: Conexi√≥n b√°sica al endpoint multiplayer"""
        print("üß™ TEST 1: CONEXI√ìN B√ÅSICA MULTIPLAYER")
        print("-" * 50)
        
        try:
            uri = f"{self.base_url}/ws/multiplayer"
            async with websockets.connect(uri, timeout=10) as websocket:
                print(f"‚úÖ Conectado a {uri}")
                
                # Esperar mensaje inicial
                try:
                    message = await asyncio.wait_for(websocket.recv(), timeout=5)
                    data = json.loads(message)
                    print(f"üì• Mensaje inicial recibido:")
                    print(f"   Tipo: {data.get('type', 'N/A')}")
                    print(f"   Status: {data.get('status', 'N/A')}")
                    print(f"   Message: {data.get('message', 'N/A')}")
                    
                    self.test_results.append(("Conexi√≥n Multiplayer", True))
                    return True
                    
                except asyncio.TimeoutError:
                    print(f"‚è∞ No se recibi√≥ mensaje inicial")
                    self.test_results.append(("Conexi√≥n Multiplayer", False))
                    return False
                    
        except Exception as e:
            print(f"‚ùå Error conectando: {e}")
            self.test_results.append(("Conexi√≥n Multiplayer", False))
            return False
    
    async def test_authentication_flow(self):
        """Test 2: Flujo de autenticaci√≥n de jugador"""
        print(f"\nüß™ TEST 2: AUTENTICACI√ìN DE JUGADOR")
        print("-" * 50)
        
        try:
            uri = f"{self.base_url}/ws/multiplayer"
            async with websockets.connect(uri, timeout=10) as websocket:
                print(f"‚úÖ Conectado para autenticaci√≥n")
                
                # Enviar autenticaci√≥n
                auth_message = {
                    "type": "authenticate",
                    "player_name": "TestPlayer1",
                    "session_id": f"test-session-{int(time.time())}"
                }
                await websocket.send(json.dumps(auth_message))
                print(f"üì§ Enviado: {auth_message}")
                
                # Esperar respuesta de autenticaci√≥n
                try:
                    response = await asyncio.wait_for(websocket.recv(), timeout=10)
                    data = json.loads(response)
                    print(f"üì• Respuesta de auth:")
                    print(f"   Tipo: {data.get('type', 'N/A')}")
                    print(f"   Success: {data.get('success', 'N/A')}")
                    print(f"   Player ID: {data.get('player_id', 'N/A')}")
                    print(f"   Session ID: {data.get('session_id', 'N/A')}")
                    
                    success = data.get('success', False)
                    self.test_results.append(("Autenticaci√≥n", success))
                    return success
                    
                except asyncio.TimeoutError:
                    print(f"‚è∞ Timeout esperando respuesta de auth")
                    self.test_results.append(("Autenticaci√≥n", False))
                    return False
                    
        except Exception as e:
            print(f"‚ùå Error en autenticaci√≥n: {e}")
            self.test_results.append(("Autenticaci√≥n", False))
            return False
    
    async def test_game_commands(self):
        """Test 3: Comandos de juego"""
        print(f"\nüß™ TEST 3: COMANDOS DE JUEGO")
        print("-" * 50)
        
        try:
            uri = f"{self.base_url}/ws/multiplayer"
            async with websockets.connect(uri, timeout=10) as websocket:
                
                # Autenticarse primero
                auth_message = {
                    "type": "authenticate",
                    "player_name": "CommandTester",
                    "session_id": f"cmd-test-{int(time.time())}"
                }
                await websocket.send(json.dumps(auth_message))
                
                # Esperar respuesta de auth
                await asyncio.wait_for(websocket.recv(), timeout=5)
                
                # Test comando: look
                look_command = {
                    "type": "game_command",
                    "command": "look",
                    "args": []
                }
                await websocket.send(json.dumps(look_command))
                print(f"üì§ Comando enviado: look")
                
                try:
                    response = await asyncio.wait_for(websocket.recv(), timeout=10)
                    data = json.loads(response)
                    print(f"üì• Respuesta comando:")
                    print(f"   Tipo: {data.get('type', 'N/A')}")
                    print(f"   Result: {data.get('result', 'N/A')[:100]}...")
                    
                    self.test_results.append(("Comandos de Juego", True))
                    return True
                    
                except asyncio.TimeoutError:
                    print(f"‚è∞ Timeout esperando respuesta de comando")
                    self.test_results.append(("Comandos de Juego", False))
                    return False
                    
        except Exception as e:
            print(f"‚ùå Error en comandos: {e}")
            self.test_results.append(("Comandos de Juego", False))
            return False
    
    async def test_multiple_players(self):
        """Test 4: M√∫ltiples jugadores simult√°neos"""
        print(f"\nüß™ TEST 4: M√öLTIPLES JUGADORES")
        print("-" * 50)
        
        players = []
        try:
            # Conectar 3 jugadores
            for i in range(3):
                uri = f"{self.base_url}/ws/multiplayer"
                websocket = await websockets.connect(uri, timeout=10)
                
                # Autenticar cada jugador
                auth_message = {
                    "type": "authenticate",
                    "player_name": f"Player{i+1}",
                    "session_id": f"multi-test-{i+1}-{int(time.time())}"
                }
                await websocket.send(json.dumps(auth_message))
                
                # Esperar respuesta
                response = await asyncio.wait_for(websocket.recv(), timeout=5)
                data = json.loads(response)
                
                if data.get('success'):
                    players.append(websocket)
                    print(f"‚úÖ Jugador {i+1} conectado: {data.get('player_id')}")
                else:
                    await websocket.close()
                    print(f"‚ùå Jugador {i+1} fall√≥ autenticaci√≥n")
            
            print(f"üìä Jugadores conectados: {len(players)}")
            
            # Test comunicaci√≥n entre jugadores
            if len(players) >= 2:
                # Player 1 env√≠a mensaje
                chat_message = {
                    "type": "chat",
                    "message": "Hola a todos desde Player1!"
                }
                await players[0].send(json.dumps(chat_message))
                print(f"üì§ Player1 envi√≥ chat: {chat_message['message']}")
                
                # Verificar que otros jugadores reciban el mensaje
                received_count = 0
                for i, player in enumerate(players[1:], 2):
                    try:
                        response = await asyncio.wait_for(player.recv(), timeout=3)
                        data = json.loads(response)
                        if data.get('type') == 'chat':
                            received_count += 1
                            print(f"üì• Player{i} recibi√≥ chat")
                    except asyncio.TimeoutError:
                        print(f"‚è∞ Player{i} no recibi√≥ chat")
                
                success = received_count > 0
                self.test_results.append(("M√∫ltiples Jugadores", success))
                print(f"üìä Mensajes recibidos: {received_count}/{len(players)-1}")
            
            # Cerrar conexiones
            for player in players:
                await player.close()
            
            return len(players) >= 2
            
        except Exception as e:
            print(f"‚ùå Error en test multi-jugador: {e}")
            # Cerrar conexiones abiertas
            for player in players:
                try:
                    await player.close()
                except:
                    pass
            self.test_results.append(("M√∫ltiples Jugadores", False))
            return False
    
    async def test_real_time_sync(self):
        """Test 5: Sincronizaci√≥n en tiempo real"""
        print(f"\nüß™ TEST 5: SINCRONIZACI√ìN TIEMPO REAL")
        print("-" * 50)
        
        try:
            uri = f"{self.base_url}/ws/multiplayer"
            async with websockets.connect(uri, timeout=10) as websocket:
                
                # Autenticarse
                auth_message = {
                    "type": "authenticate",
                    "player_name": "SyncTester",
                    "session_id": f"sync-test-{int(time.time())}"
                }
                await websocket.send(json.dumps(auth_message))
                await asyncio.wait_for(websocket.recv(), timeout=5)
                
                # Ejecutar acci√≥n que afecte el mundo
                action_message = {
                    "type": "game_command",
                    "command": "inventory",
                    "args": []
                }
                await websocket.send(json.dumps(action_message))
                print(f"üì§ Comando sincronizaci√≥n enviado")
                
                # Escuchar m√∫ltiples mensajes (sincronizaci√≥n)
                sync_messages = 0
                for i in range(3):
                    try:
                        response = await asyncio.wait_for(websocket.recv(), timeout=3)
                        data = json.loads(response)
                        print(f"üì• Mensaje sync {i+1}: {data.get('type', 'N/A')}")
                        sync_messages += 1
                    except asyncio.TimeoutError:
                        break
                
                success = sync_messages > 0
                self.test_results.append(("Sincronizaci√≥n", success))
                print(f"üìä Mensajes de sincronizaci√≥n: {sync_messages}")
                return success
                
        except Exception as e:
            print(f"‚ùå Error en sincronizaci√≥n: {e}")
            self.test_results.append(("Sincronizaci√≥n", False))
            return False
    
    async def run_all_tests(self):
        """Ejecutar todos los tests"""
        print("üöÄ INICIANDO TESTS COMPLETOS DEL ENDPOINT MULTIPLAYER")
        print("=" * 70)
        print(f"‚è∞ Inicio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print()
        
        tests = [
            ("Conexi√≥n B√°sica", self.test_basic_connection),
            ("Autenticaci√≥n", self.test_authentication_flow),
            ("Comandos de Juego", self.test_game_commands),
            ("M√∫ltiples Jugadores", self.test_multiple_players),
            ("Sincronizaci√≥n", self.test_real_time_sync),
        ]
        
        for test_name, test_func in tests:
            print(f"\nüîç Ejecutando: {test_name}")
            start_time = time.time()
            
            try:
                result = await test_func()
                duration = time.time() - start_time
                status = "‚úÖ PASS" if result else "‚ùå FAIL"
                print(f"üìä {test_name}: {status} ({duration:.2f}s)")
            except Exception as e:
                duration = time.time() - start_time
                print(f"üìä {test_name}: ‚ùå ERROR ({duration:.2f}s) - {e}")
                self.test_results.append((test_name, False))
        
        # Mostrar resultados finales
        self.show_results()
    
    def show_results(self):
        """Mostrar resultados finales"""
        print("\n" + "=" * 70)
        print("üìä RESULTADOS FINALES - ENDPOINT MULTIPLAYER")
        print("-" * 70)
        
        passed = sum(1 for _, result in self.test_results if result)
        total = len(self.test_results)
        
        print(f"üèÜ Tests pasados: {passed}/{total} ({passed/total*100:.1f}%)")
        
        for test_name, result in self.test_results:
            status = "‚úÖ PASS" if result else "‚ùå FAIL"
            print(f"  ‚Ä¢ {test_name}: {status}")
        
        # Diagn√≥stico
        print(f"\nüîç DIAGN√ìSTICO FINAL")
        print("-" * 70)
        
        if passed == total:
            print("üü¢ TODOS LOS TESTS PASARON")
            print("üéâ El endpoint /ws/multiplayer est√° completamente funcional")
            print("‚úÖ Listo para producci√≥n")
        elif passed >= total * 0.8:
            print("üü° MAYOR√çA DE TESTS PASARON")
            print("üëç El endpoint funciona en general")
            print("üîß Algunos ajustes menores requeridos")
        else:
            print("üî¥ M√öLTIPLES PROBLEMAS DETECTADOS")
            print("üõ†Ô∏è Requiere revisi√≥n y correcciones")
        
        print(f"\n‚è∞ Completado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

async def main():
    """Funci√≥n principal"""
    tester = MultiPlayerWebSocketTester()
    await tester.run_all_tests()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print(f"\n‚ö†Ô∏è Tests interrumpidos por el usuario")
    except Exception as e:
        print(f"\n‚ùå Error en main: {e}")
        import traceback
        traceback.print_exc()
